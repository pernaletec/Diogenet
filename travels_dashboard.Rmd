---
title: "Diogenet's Map"
subtitle: "Intellectual Networks from Ancient Greece"
output: 
  flexdashboard::flex_dashboard:
        orientation: rows
        favicon: iah_classicalstudies_logo_fv_pq.png
        navbar:
          - { icon: "fa-home", href: " http://diogenet.ucsd.edu", align: right }
        runtime: shiny
---

```{r setup, include=FALSE}
library(tidyverse)
library(devtools)
library(leaflet)
library(shiny)
library(DT)
library(geosphere)
library(viridis)
library(igraph)
library(visNetwork)
library(flexdashboard)
library(rmarkdown)
library(knitr)
library(rsconnect)
```
```{r global, include=FALSE}
#Functions
travelsData <- function(nodes, black_list, all_places_full_data, edges){
##################### This function with arguments (nodes, travels_blacklist, locations_data, edges) #######################################
###################### 1. create a new table from Nodes and Edges dataset. #################################################################
###################### 2. identify nodes that are in both relations "is from" and "travelled to" ###########################################
###################### 3. Create a dataframe with the follow form:  source target name lat_source lat_targer lon_source lon_target #########
  
  # Filter the nodes that are places
  places <- nodes$Name[nodes$Groups=="Place"]
  # Filter the places for whom location is available
  # Note that pipe the pipe operator %in% is used here 
  places_available = places[places %in% all_places_full_data$name]
  
  ##############################################################################
  ########################### Selecting travels data ###########################
  ##############################################################################
  
  ## 1. create new table from newNodes and newEdges.
  ## 2. identify nodes that are in both relations "is from" and "travelled to"
  
  # Origin of phylosophers 
  names_origin <- edges$Source[which(edges$Relation == "is from")]
  origin_places <- edges$Target[which(edges$Relation == "is from")]
  
  # Validations!!!!
  # Do places as Target in "is from" have identified localization??
  id_knw_orig <- which(origin_places %in% places_available)
  # Known places
  knw_origin_loc <- origin_places[id_knw_orig]
  # Unknown places
  unk_origin_loc <- origin_places[-id_knw_orig]
  # Phylosophers with known origin
  knw_origin_phy <- names_origin[id_knw_orig]
  # Phylosophers with unknown origin
  unk_origin_phy <- names_origin[-id_knw_orig]
  
  # Travelers!
  names_traveler <- edges$Source[which(edges$Relation == "traveled to")]
  # Travelers in black list
  trav_in_BL = names_traveler %in% black_list
  names_traveler = names_traveler[!trav_in_BL]
  
  # Traveler target in black list  
  traveler_target <- edges$Target[which(edges$Relation == "traveled to")]
  traveler_target = traveler_target[!trav_in_BL]
  
  # Validations!!!!
  # Which travelers are from known origin??
  id_knw_loc_orig_trav = which(names_traveler %in% knw_origin_phy)
  # Every traveler is from a known loc place?
  isTRUE(length(id_knw_loc_orig_trav) == length(names_traveler)) 
  # How many traveler's origin need to be identified?
  dif_trav = length(names_traveler) - length(id_knw_loc_orig_trav)
  # Do every destination have a known location?
  id_knw_loc_trav_dest = which(traveler_target %in% places_available)
  # Joint condition "known location origin phylosopher" + "known location traveler destrination"
  intsect_condition = intersect(id_knw_loc_orig_trav,id_knw_loc_trav_dest)
  
  # Travelers with joint condition 
  knw_all_names_trav = names_traveler[intsect_condition]
  # Destinations with joint condition
  knw_all_travl_trgt = traveler_target[intsect_condition]
  
  ################################################################################
  ## In the following lines a table will be built for nodes in "travelled to"   ##
  ## but not in "is from". A column will be added to show weather or not these  ##
  ## places have an identified location                                         ##
  ################################################################################
  
  # nodes in "travelled to" but not in "is from"
  id_travelers_in_is_from = which(names_traveler %in% names_origin)
  travelers_not_in_is_from = unique(names_traveler[-id_travelers_in_is_from])
  
  travelers_names = unique(names_traveler)
  
  full_travel_edges = list(name = travelers_names,
                           from = rep("", length(travelers_names)),
                           to = rep("", length(travelers_names)))
  
  traveler_source = function (x) {
    id = which(names_origin %in% x) 
    return(origin_places[id])
  }
  
  traveler_destiny = function (x) {
    id = which(names_traveler %in% x) 
    return(traveler_target[id])
  }
  
  full_travel_edges$from = sapply(full_travel_edges$name, traveler_source)
  full_travel_edges$to = sapply(full_travel_edges$name, traveler_destiny)
  
  travels_to_edit = data.frame(name = c(0), from = c(0), to = c(0))
  
  i = 1
  falta = TRUE
  cum_index = 0
  
  while (falta  == TRUE) {
    
    from = full_travel_edges$from[[i]]
    to = full_travel_edges$to[[i]]
    
    l_from = length(from)
    l_to = length(to)
    
    max_val = max(c(l_from, l_to))
    
    for (k in 1:max_val) {
      if(!is.null(full_travel_edges$name[[i]])) travels_to_edit[cum_index+k,1] = full_travel_edges$name[[i]]
      if(!is.null(from[k]) && !is.na(from[k])) travels_to_edit[cum_index+k,2] = from[k]
      if(!is.null(to[k]) && !is.na(to[k])) travels_to_edit[cum_index+k,3] = to[k]
    }
    cum_index = cum_index + k
    i = i+1
    if (i > length(full_travel_edges$name)) falta = FALSE
  }
  ################################################################################
  
  
  ## 3. turn it into something like this:
  ##   source   target  name
  ##   Athens   Egypt   Pythagoras
  
  travel_edges = data.frame(source = rep("", length(knw_all_names_trav)), 
                            target = knw_all_travl_trgt, 
                            name=knw_all_names_trav,
                            lat_source=rep("", length(knw_all_names_trav)), 
                            lon_source = rep("", length(knw_all_names_trav)),
                            lat_target=rep("", length(knw_all_names_trav)), 
                            lon_target = rep("", length(knw_all_names_trav)),
                            stringsAsFactors = FALSE)
  
  ## After getting all the places for which there IS at least one location identified 
  ## there was a "manual" search using the shiny app developed
  #all_places_full_data = read.csv(file = "locations_data.csv", header = TRUE, sep = ",", dec = ".", stringsAsFactors = FALSE)
  
  # Some Phylosophers are identified with more that one "is from" Relation
  # Keep that in mind!
  
  for (k in 1:length(travel_edges$source)) {
    # print(paste0(k, " ", knw_origin_loc[which(knw_origin_phy == travel_edges$name[k])]))
    # print(paste0(k, " ", travel_edges$name[k]))
    travel_edges$source[k] = (knw_origin_loc[which(knw_origin_phy == travel_edges$name[k])])
    travel_edges$lat_source[k] = (all_places_full_data$lat[which(all_places_full_data$name == travel_edges$source[k])])
    travel_edges$lon_source[k] = (all_places_full_data$lon[which(all_places_full_data$name == travel_edges$source[k])])
    travel_edges$lat_target[k] = (all_places_full_data$lat[which(all_places_full_data$name == travel_edges$target[k])])
    travel_edges$lon_target[k] = (all_places_full_data$lon[which(all_places_full_data$name == travel_edges$target[k])])
  }
  
  all_places = sort(unique(c(travel_edges$source, travel_edges$target)), decreasing = FALSE)
  # These are the nodes in the graph
  all_places = data.frame(places = all_places)
  return(travel_edges)
}
CentralityValues <- function (graph){
# This function take a graph object argument and return a dataframe with centrality scores (degree, betweenness, closeness, eigenvector)
  
  if (is.igraph(graph)) {  
    
    val =  data.frame(degree = igraph::degree(graph),
    betweenness = as.numeric(format(igraph::betweenness(graph, normalized =TRUE),digits = 3, nsmall = 3)),
                     closeness = as.numeric(format(igraph::closeness(graph),digits = 3, nsmall = 3)),
                     eigenvector = as.numeric(format(igraph::eigen_centrality(graph)$vector,digits = 3, nsmall = 3)))
  return(val)
  } else {
    val <- graph
  }
}
CentralizationValues <- function(graph){
  # This function take a graph object argument and return a dataframe with centralization scores (degree, betweenness, closeness, eigenvector)
    centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                     betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1], 
                                                     digits = 3, nsmall = 3)),
                     closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                     eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1], 
                                                     digits = 3, nsmall = 3))
                     )
    row.names(centr_) = c("Graph")
    return(centr_)
}


# Reads the black list for datasets
black_list = read.csv(file="travels_blacklist.csv", header = FALSE, sep = ",", encoding = "UTF-8", stringsAsFactors = FALSE)
# Reads the locations data for datasets
all_places_full_data = read.csv(file = "locations_data.csv", header = TRUE, sep = ",", dec = ".", stringsAsFactors = FALSE)

##################### Here is the call of the edges and nodes of the different datasets #####################################################
######################################################################
####################  Diogenes Dataset ###############################
######################################################################
# Reads the nodes file
nodes_diogenes = read.csv(file="new_Nodes.csv", header = TRUE, sep = ",", encoding = "UTF-8", stringsAsFactors = FALSE)
# Reads the edges file
edges_diogenes = read.csv(file="new_Edges.csv", header = TRUE, sep = ",", encoding = "UTF-8", stringsAsFactors = FALSE)
######################################################################
###############  Life of Pythagoras Lamblichus Dataset ###############
######################################################################
#read nodes file
nodes_LOPL <- read.csv(file="new_Nodes_Life_of_Pythagoras_Iamblichus.csv", header = TRUE, sep = ",", encoding = "UTF-8", stringsAsFactors = FALSE)
# read edges file
edges_LOPL <- read.csv("new_Edges_Life_of_Pythagoras_Iamblichus.csv", header = TRUE, sep = ",", encoding = "UTF-8", stringsAsFactors = FALSE)


##################### Here is the travels edges of the different datasets #####################################################
# Travel edges for Diogenes dataset
travel_edges <- travelsData(nodes_diogenes, black_list, all_places_full_data, edges_diogenes)
# Travel edges for Life Of Pythagoras Lamblichus (LOPL) dataset
travel_edges_LOPL <- travelsData(nodes_LOPL, black_list, all_places_full_data, edges_LOPL)

```
Travels
======================================

Inputs {.sidebar}
--------------------------------------

```{r}

# Re-scale sliders

# a and b are the desired initial values in the original scale 
# The function return the 0 and 10 values for the 0-10 scale
# The function is built using the a=4 and b=6 values (desired values)
rescaled_value = function(a,b,x) {
  y = ((b-a)/(6-4))*(x-4)+a
  return(y)
}

# Function to rescale node degree
rescale <- function(x,a,b,c,d){c + (x-a)/(b-a)*(d-c)}

# Menu de seleccion del dataset
selectInput(inputId= "dataset_selection", 
            label = "select a dataset", 
            choices = c("Diogenes Laertius" = "diogenes", "Lamblichus" = "LOPL"),
            selected = "diogenes")



# Menu reactivo que se muestra cuando es seleccionado
uiOutput(outputId = 'travelerInput')
selectInput("centrality_type",
            label = "Select a Centrality type",
            c("Degree" = "degree",
              "Betweenness" = "betweenness",
              "Closeness" = "closeness",
              "Eigenvector" = "eigenvector"))

br()
h4("Appearance")
sliderInput(inputId = "label_size_map", label = "Label Size", min = 0.0, max = 10.0, value = c(4, 6),ticks = TRUE, step = 1)
sliderInput(inputId = "node_size_map", label = "Node Size", min = 0.0, max = 10.0, value = c(4, 6),ticks = TRUE, step = 1)

#boton de subir archivo que se muestra cuando es elegida la opcion custom
fileInput(inputId = "custom_dataset", 
              label = "Upload a custom dataset", 
              multiple = FALSE, 
              accept = c("text/csv", "text/comma-separated-values,text/plain",".csv"))


#div(message, style = "color:red")

```

Row {.tabset}
-------------------------------------

### Map

```{r, echo = FALSE, message = FALSE}
# Travel edges for Custom dataset
travel_edges_custom <- reactive({
    inFile <- input$custom_dataset
    if (is.null(inFile))
      return(NULL)
    df <- read.csv(inFile$datapath, header = TRUE, sep = ",", encoding = "UTF-8", stringsAsFactors = FALSE)
    return(df)
  })

# the "custom" option is shown in the selectInput "select a dataset" if a .csv file is uploaded
 observe({
    x <- input$custom_dataset

    # Can use character(0) to remove all 
    if (!is.null(x)){
      updateSelectInput(session, "dataset_selection",
      label = "select a dataset",
      choices = c("Diogenes Laertius" = "diogenes", "Lamblichus" = "LOPL", "Custom" = "custom"),
      selected = "diogenes"
      )
    }
    
  })

# the list of names in SelectInput "Select a Traveler" is updated based on the selected dataset
output$travelerInput <- renderUI({
  # This input exists if the `dataset_selection`
  if (input$dataset_selection == 'diogenes') {
    selectInput(inputId = "philosopher", 
                label = "Select a Traveler", 
                choices = c("All", sort(travel_edges$name, decreasing = FALSE)), 
                selected = "All")
  } else if (input$dataset_selection == 'LOPL') {
    selectInput(inputId = "philosopher_LOPL", 
                label = "Select a Traveler", 
                choices = c("All", sort(travel_edges_LOPL$name, decreasing = FALSE)), 
                selected = "All")
  }  else if (input$dataset_selection == 'custom') {
    travel_edges_custom <- travel_edges_custom()
    selectInput(inputId = "philosopher_custom", 
                label = "Select a Traveler", 
                choices = c("All", sort(travel_edges_custom$name, decreasing = FALSE)), 
                selected = "All")
  } 
  else {
    return(NULL)
  }
})


# Reactive travel edges expression for Diogenes dataset
travel_edges_reactive = reactive({
  # Filter by Phylosopher selected...if any
  if ((input$philosopher != "All") && !is.null(input$philosopher)) {
    travel_edges_selected = travel_edges$name %in% input$philosopher
    return(travel_edges[travel_edges_selected,])
  } else  return(travel_edges)
})
# Reactive travel edges expression for  Life of pythagroas Lamblichus dataset
travel_edges_LOPL_reactive <- reactive({
    # Filter by Phylosopher selected...if any
    if ((input$philosopher_LOPL != "All") && !is.null(input$philosopher_LOPL)) {
      travel_edges_selected <- travel_edges_LOPL$name %in% input$philosopher_LOPL
      return(travel_edges_LOPL[travel_edges_selected,])
    } else return(travel_edges_LOPL)
})
# Reactive travel edges expression for  Custom dataset
travel_edges_custom_reactive <- reactive({
  travel_edges_custom <- travel_edges_custom()
  # Filter by Phylosopher selected...if any
  if ((input$philosopher_custom != "All") && !is.null(input$philosopher_custom)) {
    travel_edges_selected <- travel_edges_custom$name %in% input$philosopher_custom
    return(travel_edges_custom[travel_edges_selected,])
  } else return(travel_edges_custom)
})

# Reactive places expression for Diogenes dataset
all_places_reactive = reactive({
  travel_edges = travel_edges_reactive()
  all_places = sort(unique(c(travel_edges$source,
                             travel_edges$target)), 
                    decreasing = FALSE)
  # These are the nodes in the graph
  return(data.frame(places = all_places))
})
# Reactive places expression for Life of pythagroas Lamblichus dataset
all_places_LOPL_reactive <- reactive({
  travel_edges_LOPL <- travel_edges_LOPL_reactive()
  all_places_LOPL <- sort(unique(c(travel_edges_LOPL$source,
                                   travel_edges_LOPL$target)),
                          decreasing = FALSE)
  return(data.frame(places_LOPL = all_places_LOPL))
})
# Reactive places expression for Custom dataset
all_places_custom_reactive <- reactive({
  travel_edges_custom = travel_edges_custom_reactive()
  all_places_custom = sort(unique(c(travel_edges_custom$source,
                             travel_edges_custom$target)), 
                    decreasing = FALSE)
  # These are the nodes in the graph
  return(data.frame(places = all_places_custom))
})


# Reactive all places full data expression for Diogenes dataset
all_places_full_data_reactive = reactive({
  all_places = all_places_reactive()
  drawn_places = all_places_full_data$name %in% all_places
  return(all_places_full_data[drawn_places,])
})
# Reactive all places full data expression for Life of Pythagoras Lamblichus dataset
all_places_full_data__LOPL_reactive <- reactive({
  all_places_LOPL <- all_places_LOPL_reactive()
  drawn_places_LOPL <- all_places_full_data$name %in% all_places_LOPL
  return(all_places_full_data[drawn_places_LOPL,])
})
# Reactive all places full data expression for Custom dataset
all_places_full_data_custom_reactive <- reactive({
  all_places = all_places_custom_reactive()
  drawn_places = all_places_full_data$name %in% all_places
  return(all_places_full_data[drawn_places,])
})

#Graph creaction
# Reactive graph expression for Diogenes dataset
graph_reactive = reactive({
  
  ###############################################################################################
  ###################################                     #######################################  
  ##################################    GRAPH CREATION     ######################################
  ###################################                     #######################################
  ###############################################################################################
  
  travel_edges = travel_edges_reactive()
    all_places = all_places_reactive()
    
    centralities_data = TRUE
    # First validate if there are at least two nodes
    if (length(all_places$places)<2) centralities_data  = FALSE
    
    #print(centralities_data)
    
    try(graph <- igraph::graph_from_data_frame(d = travel_edges[,1:2], 
                                               directed=FALSE, 
                                               vertices = all_places$places), 
        silent = TRUE)
    
    if(centralities_data) return(graph)
    else return("Too few (<2) nodes to calculate centralities")
  
})
# Reactive graph expression for Life of Pythagoras Lamblichus dataset
graph_reactive_LOPL <- reactive({
  
  travel_edges <- travel_edges_LOPL_reactive()
  all_places <- all_places_LOPL_reactive()
    
  centralities_data = TRUE
  # First validate if there are at least two nodes
  if (length(all_places$places)<2) centralities_data  = FALSE
    
  #print(centralities_data)
  # revisar lo del travel
  try(graph <- igraph::graph_from_data_frame(d = travel_edges[,1:2], 
                                             directed=FALSE, 
                                             vertices = all_places$places), 
        silent = TRUE)
    
  if(centralities_data) return(graph)
  else return("Too few (<2) nodes to calculate centralities")
})
# Reactive graph expression for Custom dataset
graph_reactive_custom <- reactive({
  
  travel_edges <- travel_edges_custom_reactive()
  all_places <- all_places_custom_reactive()
    
    centralities_data = TRUE
    # First validate if there are at least two nodes
    if (length(all_places$places)<2) centralities_data  = FALSE
    
    #print(centralities_data)
    # revisar lo del travel
    try(graph <- igraph::graph_from_data_frame(d = travel_edges[,2:3], 
                                               directed=FALSE, 
                                               vertices = all_places$places), 
        silent = TRUE)
    
    if(centralities_data) return(graph)
    else return("Too few (<2) nodes to calculate centralities")
  
})


# network stores an object rendered by renderVisnetwork
output$travels_network = renderLeaflet({
  
  tcu_map = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}"
  
  map_attr = "Map data &copy<a href='https://developers.arcgis.com/esri-leaflet/maps/display-a-map/'>ArcGIS</a> contributors <a href='http://creativecommons.org/licenses/by-sa/2.0/'>CC-BY-SA</a> Imagery © <a href='https://developers.arcgis.com/'>ArcGIS</a>"
  
  # This line is not requiered
  #m <- leaflet(avail_data_tb) %>% 
  m <- leaflet() %>% 
    addTiles(urlTemplate = tcu_map, attribution = map_attr, options = list(maxZoom = 10, 
                                                                           id = 'isawnyu.map-knmctlkh',
                                                                           accessToken =  'pk.eyJ1IjoiaXNhd255dSIsImEiOiJBWEh1dUZZIn0.SiiexWxHHESIegSmW8wedQ'))%>%
    setView(lng= 24.92, lat = 35.255, zoom = 5) 
  m
  
  # saveWidget(m, file = "map.html", selfcontained = TRUE)
})

# rescale the radius of the marker to the min_scale-max_scale scale (5-20)
rescale_radius = function(x, min, max, min_scale, max_scale){
  if (min != max) y = ((max_scale-min_scale)/(max-min))*(x-min)+min_scale
  else y = min_scale
  return(y)
}

# x in this function is centrality vector
col_index = function(x, n_col, min, max) {((n_col -1)/(max - min))*(x-min)+1}

returnColor = function(char_col) {substr(char_col,1,nchar(char_col)-2)}

# observe
observe({
  
  req(input$dataset_selection)
  if (input$dataset_selection == 'LOPL') {
    travel_edges <- travel_edges_LOPL_reactive()
    all_places <- all_places_LOPL_reactive()
    graph <- graph_reactive_LOPL()
    values = values_LOPL()
  }  else if (input$dataset_selection == 'diogenes') {
    travel_edges = travel_edges_reactive()
    all_places = all_places_reactive()
    graph = graph_reactive()
    values = values()
  } else if (input$dataset_selection == 'custom') {
    travel_edges = travel_edges_custom_reactive()
    all_places = all_places_custom_reactive()
    graph = graph_reactive_custom()
    values = values_custom()
  }

  ###############################################################################################
  ###################################                     #######################################
  ##################################     LEAFLET MAP       ######################################
  ###################################                     #######################################
  ###############################################################################################
  
  avail_data_tb = as_tibble(travel_edges)

  node_count = c(travel_edges$source, travel_edges$target)
  node_count = as.data.frame(table(node_count))

  all_places_full_data = all_places_full_data[(all_places_full_data$name %in% all_places$places),]
  all_places_full_data = all_places_full_data[order(all_places_full_data$name, decreasing = FALSE),]
  
  all_places_full_data$degree = values$degree
  all_places_full_data$betweenness = values$betweenness
  all_places_full_data$closeness = values$closeness
  all_places_full_data$eigenvector = values$eigenvector
  
  n_col =  50
  node_vir_col = viridis(n = n_col, begin =  0.55, end = 1.0, direction = 1, option = "B")
  node_vir_col = returnColor(node_vir_col)
  
  if (!is.null(input$centrality_type)) {
  
    if (input$centrality_type == "degree") {
      centrality = all_places_full_data$degree
    }
    if (input$centrality_type == "betweenness") {
      centrality = all_places_full_data$betweenness      
    }
    if (input$centrality_type == "closeness") {
      centrality = all_places_full_data$closeness
    }
    if (input$centrality_type == "eigenvector") {
      centrality = all_places_full_data$eigenvector
    }
    
    all_places_full_data$centrality = centrality
    
    #La siguiente ecuación no se usa. 
    #col_index_vector = col_index(centrality, n_col = n_col, min = min, max = max)
    
    # pal  = colorNumeric(palette = "magma", domain = centrality)
    # Cambio de enfoque
    if (length(centrality) > 2) {
      pal <- colorNumeric(node_vir_col, domain = centrality)
      min = min(centrality)
      max = max(centrality)
    } else {
      pal <- colorNumeric(node_vir_col, domain = c(1:10))
      min = 1
      max = 10
      
    }
    
    # Set node size
    if (is.null(input$node_size_map[1])) min_node = rescaled_value(5,20,4)
    else min_node = rescaled_value(5,20,input$node_size_map[1])

    if (is.null(input$node_size_map[2])) max_node = rescaled_value(5,20,6)
    else max_node = rescaled_value(5,20,input$node_size_map[2])

    # print("centrality")
    # print(centrality)
    # print("length(centrality) > 2")
    # print(length(centrality) > 2)
    # print(pal)
    # print(min)
    # print(max)
    
    text_title = input$centrality_type
  
    leafletProxy("travels_network") %>%
      clearShapes() %>%
      clearMarkers() %>%
      clearControls()
  
    for(i in 1:length(travel_edges$source)) {
      arc <- gcIntermediate( p1 = c(as.numeric(travel_edges$lon_source[i]), as.numeric(travel_edges$lat_source[i])),
                             p2 = c(as.numeric(travel_edges$lon_target[i]), as.numeric(travel_edges$lat_target[i])),
                             n=100, addStartEnd=TRUE )
        leafletProxy("travels_network") %>% addPolylines(
                          data=arc,
                          color="black",
                          weight=1,
                          stroke = TRUE,
                          smoothFactor = 5,
                          fillOpacity = 0.75, popup = paste0("<p><center><b>", travel_edges$name[i],
                                                             "</b><br/><small><i>From: </i>",
                                                              travel_edges$source[i],
                                                              "<br/><i>To: </i>",
                                                              travel_edges$target[i],
                                                              "<br/></small></center></p>")
                          )
    }

    #str(viridis_pal(option = "plasma")(length(centrality)))
    
    #print(centrality)
    #print(pal)
    
    leafletProxy("travels_network") %>% 
      addCircleMarkers(data = all_places_full_data, 
                       all_places_full_data$lon,
                       all_places_full_data$lat,
                       popup=paste0("<p><center><b>",
                                    all_places_full_data$name,
                                    "</b><br/><small><i>Lat: </i>",
                                    all_places_full_data$lat,
                                    "<br/><i>Long: </i>",
                                    all_places_full_data$lon,
                                    "<br/></small></center></p>"),
                       radius=sapply(X = centrality, 
                                     FUN = rescale_radius, 
                                     min = min, 
                                     max = max, 
                                     min_scale = min_node, 
                                     max_scale = max_node),
                       color = ~pal(centrality),
                       stroke =TRUE,
                       fillOpacity = 0.75)%>%
      addLegend(position = 'bottomright',pal = pal, values = seq(min,max,length.out = 10), title = text_title)
  
  } else {
    # Else 
    
    
    
    
  }
})


# Use the visnetworkOutput function for visnetwork objects
leafletOutput(outputId="travels_network")
```

### Metrics

```{r, echo=FALSE}


############### centrality score calculations ########################
# Reactive centrality values expression for Diogenes dataset
values <- reactive({ CentralityValues(graph_reactive()) })
# Reactive centrality values expression for Life of phytagoras dataset 
values_LOPL <- reactive({ CentralityValues(graph_reactive_LOPL()) })
# Reactive centrality values expression for custom dataset
values_custom <- reactive({ CentralityValues(graph_reactive_custom()) })

############### centralization score calculations ########################
#diogenes
centr = reactive({
  
  graph = graph_reactive()
  
  centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                   closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3))
                   )
  row.names(centr_) = c("Graph")
  return(centr_)
})
#Life of phytagoras
centr_LOPL <- reactive({
  
  graph = graph_reactive_LOPL()
  
  centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                   closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3))
                   )
  row.names(centr_) = c("Graph")
  return(centr_)
})
# Custom
centr_custom <- reactive({
  
  graph = graph_reactive_custom()
  
  centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                   closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3))
                   )
  row.names(centr_) = c("Graph")
  return(centr_)
})

# Data table values
# Diogenes
output$table_values = DT::renderDataTable({datatable(values()[order(values()$degree, decreasing = TRUE),], selection = 'none', caption = 'Centrality scores', 
                                   options = list(
                                                 initComplete = JS(
                                                  "function(settings, json){",
                                                  "$(this.api().table().body()).css({'font-size': '14px'});",
                                                  "$(this.api().table().header()).css({'font-size': '12px'});",
                                                  "}"),
                                                  pageLength = 10,
                                                  lengthChange = FALSE,
                                                  processing = FALSE,
                                                  scrollX = TRUE
                                                  #,
                                                  #scrollY = TRUE,
                                                  #scrollCollapse = TRUE,
                                                  #autoWidth = TRUE
                                                  ,
                                                  columnDefs = list(list(width = '20%', targets = c(1, 2, 3, 4)),
                                                                    list(className = 'dt-center', targets = c(1, 2, 3, 4)))
                                                  ))})
# Life ofphytagoras
output$table_values_LOPL <- DT::renderDataTable({datatable(values_LOPL()[order(values_LOPL()$degree, decreasing = TRUE),], selection = 'none', caption = 'Centrality scores', 
                                   options = list(
                                                 initComplete = JS(
                                                  "function(settings, json){",
                                                  "$(this.api().table().body()).css({'font-size': '14px'});",
                                                  "$(this.api().table().header()).css({'font-size': '12px'});",
                                                  "}"),
                                                  pageLength = 10,
                                                  lengthChange = FALSE,
                                                  processing = FALSE,
                                                  scrollX = TRUE
                                                  #,
                                                  #scrollY = TRUE,
                                                  #scrollCollapse = TRUE,
                                                  #autoWidth = TRUE
                                                  ,
                                                  columnDefs = list(list(width = '20%', targets = c(1, 2, 3, 4)),
                                                                    list(className = 'dt-center', targets = c(1, 2, 3, 4)))
                                                  ))})
# Custom
output$table_values_custom <- DT::renderDataTable({datatable(values_custom()[order(values_custom()$degree, decreasing = TRUE),], selection = 'none', caption = 'Centrality scores', 
                                   options = list(
                                                 initComplete = JS(
                                                  "function(settings, json){",
                                                  "$(this.api().table().body()).css({'font-size': '14px'});",
                                                  "$(this.api().table().header()).css({'font-size': '12px'});",
                                                  "}"),
                                                  pageLength = 10,
                                                  lengthChange = FALSE,
                                                  processing = FALSE,
                                                  scrollX = TRUE
                                                  #,
                                                  #scrollY = TRUE,
                                                  #scrollCollapse = TRUE,
                                                  #autoWidth = TRUE
                                                  ,
                                                  columnDefs = list(list(width = '20%', targets = c(1, 2, 3, 4)),
                                                                    list(className = 'dt-center', targets = c(1, 2, 3, 4)))
                                                  ))})

# Data table centr
# Diogenes
output$table_centr = DT::renderDataTable({datatable(centr(), selection = 'none', caption = 'Centralization scores',
                                  options = list(lengthChange = FALSE,
                                                 processing = FALSE,
                                                 ordering = FALSE,
                                                 #autoWidth = TRUE,
                                                 scrollX = TRUE,
                                                 searching = FALSE,
                                                 paging = FALSE,
                                                 info = FALSE
                                                 ,
                                                 columnDefs = list(list(width = '20%', targets = c(1, 2, 3, 4)),
                                                                   list(className = 'dt-center', targets = c(1, 2, 3, 4)))
                                                 ,
                                                 initComplete = JS(
                                                    "function(settings, json){",
                                                    "$(this.api().table().body()).css({'font-size': '14px'});",
                                                    "$(this.api().table().header()).css({'font-size': '12px'});",
                                                    "$(this.api().table().header()).css({'background-color': '#326ed6', 'color': '#fff'});",
                                                    "}")
                                                 ))})
# Life of phytagoras
output$table_centr_LOPL <- DT::renderDataTable({datatable(centr_LOPL(), selection = 'none', caption = 'Centralization scores',
                                  options = list(lengthChange = FALSE,
                                                 processing = FALSE,
                                                 ordering = FALSE,
                                                 #autoWidth = TRUE,
                                                 scrollX = TRUE,
                                                 searching = FALSE,
                                                 paging = FALSE,
                                                 info = FALSE
                                                 ,
                                                 columnDefs = list(list(width = '20%', targets = c(1, 2, 3, 4)),
                                                                   list(className = 'dt-center', targets = c(1, 2, 3, 4)))
                                                 ,
                                                 initComplete = JS(
                                                    "function(settings, json){",
                                                    "$(this.api().table().body()).css({'font-size': '14px'});",
                                                    "$(this.api().table().header()).css({'font-size': '12px'});",
                                                    "$(this.api().table().header()).css({'background-color': '#326ed6', 'color': '#fff'});",
                                                    "}")
                                                 ))})
# Custom
output$table_centr_custom <- DT::renderDataTable({datatable(centr_custom(), selection = 'none', caption = 'Centralization scores',
                                  options = list(lengthChange = FALSE,
                                                 processing = FALSE,
                                                 ordering = FALSE,
                                                 #autoWidth = TRUE,
                                                 scrollX = TRUE,
                                                 searching = FALSE,
                                                 paging = FALSE,
                                                 info = FALSE
                                                 ,
                                                 columnDefs = list(list(width = '20%', targets = c(1, 2, 3, 4)),
                                                                   list(className = 'dt-center', targets = c(1, 2, 3, 4)))
                                                 ,
                                                 initComplete = JS(
                                                    "function(settings, json){",
                                                    "$(this.api().table().body()).css({'font-size': '14px'});",
                                                    "$(this.api().table().header()).css({'font-size': '12px'});",
                                                    "$(this.api().table().header()).css({'background-color': '#326ed6', 'color': '#fff'});",
                                                    "}")
                                                 ))})

uiOutput("dynamic_table")

output$dynamic_table <- renderUI({ 
  if (input$dataset_selection == 'LOPL') {
      fillCol(DT::DTOutput(outputId = 'table_centr_LOPL'),
        br(),
        DT::DTOutput(outputId = 'table_values_LOPL'), flex = c(NA,NA,NA))
  }  else if (input$dataset_selection == 'diogenes') {
      fillCol(DT::DTOutput(outputId = 'table_centr'),
            br(),
            DT::DTOutput(outputId = 'table_values'), flex = c(NA,NA,NA))
  } else if (input$dataset_selection == 'custom') {
      fillCol(DT::DTOutput(outputId = 'table_centr_custom'),
            br(),
            DT::DTOutput(outputId = 'table_values_custom'), flex = c(NA,NA,NA))
  } 
})
```

### Graph

```{r, echo=FALSE}
# visnetwork graph
#Diogenes
output$graph_map <- visNetwork::renderVisNetwork({
  
  d = graph_reactive()
  
  #print(d)
  
  directed = TRUE
  
  #Set label size
  if (is.null(input$label_size_map[1])) min_label = rescaled_value(0.3,1.0,4)
  else min_label = rescaled_value(0.3,1.0,input$label_size_map[1])

  if (is.null(input$label_size_map[2])) max_label = rescaled_value(0.3,1.0,6)
  else max_label = rescaled_value(0.3,1.0,input$label_size_map[2])
  
  # Set node size
  if (is.null(input$node_size_map[1])) min_node = rescaled_value(10.0,30.0,4)
  else min_node = rescaled_value(10.0,30.0,input$node_size_map[1])

  if (is.null(input$node_size_map[2])) max_node = rescaled_value(10.0,30.0,6)
  else max_node = rescaled_value(10.0,30.0,input$node_size_map[2])
  
  if (input$centrality_type == 'degree'){
    
    min_deg = min(igraph::degree(d))
    max_deg = max(igraph::degree(d))
    
    
    if (min_deg == max_deg) {
      
      min_deg = 1
      max_deg = 10
     
    } 
    
    labsize <- rescale(igraph::degree(d), 
                       min_deg, 
                       max_deg, 
                       min_label, 
                       max_label) 
      
    nodesize <- rescale(igraph::degree(d), 
                        min_deg, 
                        max_deg, 
                        min_node, 
                        max_node)
      
    n_col =  50
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is degree
    col_index = function(x) {((n_col -1)/(max_deg - min_deg))*(x-min_deg)+1}
    
    V(d)$label.cex <- labsize
    
    data <- toVisNetworkData(d)
  
    data$nodes$size = nodesize
    


    returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
     
    
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(igraph::degree(d), FUN = returnColor)
    
    data$nodes$degree = igraph::degree(d)
    
    # Setting group in visnetwork format
    data$nodes$group = data$nodes$Group

    data$nodes$color.border = sapply(igraph::degree(d), FUN = returnColor)

    # data$nodes$color.highlight = case_when(
    #   data$nodes$Group == "Male" ~ '#47e3ff',
    #   data$nodes$Group == "Female" ~ '#4d00ff',
    #   data$nodes$Group == "Place" ~ '#ff0134',
    #   data$nodes$Group == "God" ~ '#ff4c05'
    # )
    
    # Setting parameters straight in the data frame for visNetwork
    
    # print("data$edges")
    # print(data$edges)
    
    # print("length(data$edges$from)")
    # print(length(data$edges$from))
    
    data$edges$Relation = rep("to", length(data$edges$from))
    
    # print("data$edges$Relation")
    # print(data$edges$Relation)
    
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
  
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$degree,
                              '</p></center>'
                              )
    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }

    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)
      

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)

	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    }) 
  }
  if (input$centrality_type == 'betweenness'){
    
    validate(
      need(length(igraph::V(d))>2, "Betweenness calculation requieres more than two nodes")
      )
    
    if (length(igraph::V(d))>2) {
    
      min_bet = min(igraph::betweenness(d))
      max_bet = max(igraph::betweenness(d))
      
      
      if (min_bet == max_bet) {
      
        min_bet = 1
        max_bet = 10
     
      } 

      labsize <- rescale(igraph::betweenness(d), 
                         min_bet, 
                         max_bet, 
                         min_label, 
                         max_label)
      V(d)$label.cex <- labsize
  
      data <- toVisNetworkData(d)
  
      nodesize <- rescale(igraph::betweenness(d), 
                          min_bet, 
                          max_bet, 
                          min_node, 
                          max_node)
      
      data$nodes$size = nodesize

      n_col =  50
      node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
      
      # x in this function is degree
      col_index = function(x) {((n_col -1)/(max_bet - min_bet))*(x-min_bet)+1}
    
      returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
       
      # Setting parameters straight in the data frame for visNetwork
      data$nodes$color.background = sapply(betweenness(d), FUN = returnColor)
      
      data$nodes$betweenness = format(betweenness(d), digits = 3, nsmall = 3) 
  
      # Setting group in visnetwork format
      data$nodes$group = data$nodes$Group
  
      data$nodes$color.border = sapply(betweenness(d), FUN = returnColor)
  
      # data$nodes$color.highlight = case_when(
      #   data$nodes$Group == "Male" ~ '#47e3ff',
      #   data$nodes$Group == "Female" ~ '#4d00ff',
      #   data$nodes$Group == "Place" ~ '#ff0134',
      #   data$nodes$Group == "God" ~ '#ff4c05'
      # )
      
      data$edges$Relation = rep("to", length(data$edges$from))
      
      # Setting parameters straight in the data frame for visNetwork
      data$edges$color.color = rep("gray",length(data$edges$Relation))
      
      data$edges$color.highlight = rep("gray",length(data$edges$Relation))
    
      # nodes data.frame for legend
      lnodes <- data.frame(label = c("Male", "Female"),
                           shape = c( "dot"), 
                           color = c("#FF6347", "#ffa500"),
                           id = 1:2)
      
      if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
      
      # edges data.frame for legend
      ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                           label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                           arrows = arrow, 
                           font.align = "bottom")
      
      # Shows the name when hovering over the node
      data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                                data$nodes$id,
                                '</p>', 
                                '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                                data$nodes$color.background, 
                                ';">',
                                data$nodes$betweenness,
                                '</p></center>'
                                )
      
      if (directed) {
        
        # Shows the relation when hovering over the edge
        data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$from,
                                  '</p></center>', 
                                  '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                  data$edges$color.color, 
                                  ';">',
                                  data$edges$Relation,
                                  '</p></center>', 
                                  '<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$to, 
                                  '</p></center>'
                                  )  
        
      } else {
        
        # Shows the relation when hovering over the edge
        data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$to,
                                  '</p></center>', 
                                  '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                  data$edges$color.color, 
                                  ';">',
                                  data$edges$Relation,
                                  '</p></center>', 
                                  '<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$from, 
                                  '</p></center>'
                                  )
        
      }
  
      withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
        Sys.sleep(0.25)
  
        incProgress(1, detail = paste("Running visnetwork"))
        
        # Setting seed is important so the graph is always with the same configuration when starts
        set.seed(123)
  
  	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
  	      visNodes(shape = "dot") %>%
  	      visEdges(arrows =list(to = list(enabled = directed)),
  	               color = list(color = "gray",
  	                            highlight = "red")) %>%
          #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
  	      visIgraphLayout()%>%
  	      visOptions(highlightNearest = TRUE)%>%
  visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
   font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
  	    })     
    }  

  }
  if (input$centrality_type == 'closeness'){
    
    min_close = min(igraph::closeness(d))
    max_close = max(igraph::closeness(d))
    
    if (min_close == max_close) {
      
      min_close = 1
      max_close = 10
     
    } 
  
    labsize <- rescale(igraph::closeness(d), 
                       min_close, 
                       max_close, 
                       min_label, 
                       max_label)
    
    V(d)$label.cex <- labsize

    data <- toVisNetworkData(d)
    
    # print("data")
    # print(data) 
    
    nodesize <- rescale(igraph::closeness(d), 
                        min_close, 
                        max_close,
                        min_node, 
                        max_node)
    
    data$nodes$size = nodesize

    n_col =  50
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is degree
    col_index = function(x) {((n_col -1)/(max_close - min_close))*(x-min_close)+1}
  
    returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
     
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(closeness(d), FUN = returnColor)
    
    data$nodes$closeness =  format(igraph::closeness(d), digits = 3, nsmall = 3) 
    
    # Setting group in visnetwork format
    data$nodes$group = data$nodes$Group
    
    closeness_value = igraph::closeness(d)
    
    data$nodes$color.border = sapply(closeness_value, FUN = returnColor)
    
    # data$nodes$color.highlight = case_when(
    #   data$nodes$Group == "Male" ~ '#47e3ff',
    #   data$nodes$Group == "Female" ~ '#4d00ff',
    #   data$nodes$Group == "Place" ~ '#ff0134',
    #   data$nodes$Group == "God" ~ '#ff4c05'
    # )
    
    data$edges$Relation = rep("to", length(data$edges$from))
    
    # Setting parameters straight in the data frame for visNetwork
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
    
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # print("por aqui paso")
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$closeness,
                              '</p></center>'
                              )
    

    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }
    


    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)
      


	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    })
  }
  if (input$centrality_type == 'eigenvector'){
    
    min_eigen = min(igraph::eigen_centrality(d)$vector)
    max_eigen = max(igraph::eigen_centrality(d)$vector)
    
    if (min_eigen == max_eigen) {
      
      min_eigen = 1
      max_eigen = 10
     
    } 
    
    labsize <- rescale(igraph::eigen_centrality(d)$vector, 
                       min_eigen, 
                       max_eigen, 
                       min_label, 
                       max_label)
    
    V(d)$label.cex <- labsize

    data <- toVisNetworkData(d)

    nodesize <- rescale(igraph::eigen_centrality(d)$vector, 
                        min_eigen, 
                        max_eigen, 
                        min_node, 
                        max_node)
    
    data$nodes$size = nodesize

    n_col =  50
    
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is eigen_centrality
    col_index_evc = function(x) {((n_col -1.00)/(max_eigen - min_eigen))*(x - min_eigen)+1.00}
    
    col_index_evc_data = col_index_evc(igraph::eigen_centrality(d)$vector)
  
    returnColor_evc = function(x) {substr(node_vir_col[x],1,nchar(node_vir_col[x])-2)}
    
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)
    
    data$nodes$eigen = format(igraph::eigen_centrality(d)$vector, digits = 3, nsmall = 3)
    
    data$nodes$color.border = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)

    # data$nodes$color.highlight = case_when(
    #   data$nodes$Group == "Male" ~ '#47e3ff',
    #   data$nodes$Group == "Female" ~ '#4d00ff',
    #   data$nodes$Group == "Place" ~ '#ff0134',
    #   data$nodes$Group == "God" ~ '#ff4c05'
    # )
    
    data$edges$Relation = seq(1:length(data$edges$from))
    
    # Setting parameters straight in the data frame for visNetwork
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
  
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$eigen,
                              '</p></center>'
                              )
    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }

    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)

	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    })       
  }
  return(ntw)
    
  })
#Life of Phytagoras
output$graph_map_LOPL <- visNetwork::renderVisNetwork({
  
  d = graph_reactive_LOPL()
  
  directed = TRUE
  
  #Set label size
  if (is.null(input$label_size_map[1])) min_label = rescaled_value(0.3,1.0,4)
  else min_label = rescaled_value(0.3,1.0,input$label_size_map[1])

  if (is.null(input$label_size_map[2])) max_label = rescaled_value(0.3,1.0,6)
  else max_label = rescaled_value(0.3,1.0,input$label_size_map[2])
  
  # Set node size
  if (is.null(input$node_size_map[1])) min_node = rescaled_value(10.0,30.0,4)
  else min_node = rescaled_value(10.0,30.0,input$node_size_map[1])

  if (is.null(input$node_size_map[2])) max_node = rescaled_value(10.0,30.0,6)
  else max_node = rescaled_value(10.0,30.0,input$node_size_map[2])
  
  if (input$centrality_type == 'degree'){
    
    min_deg = min(igraph::degree(d))
    max_deg = max(igraph::degree(d))
    
    
    if (min_deg == max_deg) {
      
      min_deg = 1
      max_deg = 10
     
    } 
    
    labsize <- rescale(igraph::degree(d), 
                       min_deg, 
                       max_deg, 
                       min_label, 
                       max_label) 
      
    nodesize <- rescale(igraph::degree(d), 
                        min_deg, 
                        max_deg, 
                        min_node, 
                        max_node)
      
    n_col =  50
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is degree
    col_index = function(x) {((n_col -1)/(max_deg - min_deg))*(x-min_deg)+1}
    
    V(d)$label.cex <- labsize
    
    data <- toVisNetworkData(d)
  
    data$nodes$size = nodesize
    


    returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
     
    
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(igraph::degree(d), FUN = returnColor)
    
    data$nodes$degree = igraph::degree(d)
    
    # Setting group in visnetwork format
    data$nodes$group = data$nodes$Group

    data$nodes$color.border = sapply(igraph::degree(d), FUN = returnColor)
    
    data$edges$Relation = rep("to", length(data$edges$from))
    
    
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
  
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$degree,
                              '</p></center>'
                              )
    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }

    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)
      

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)

	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    }) 
  }
  if (input$centrality_type == 'betweenness'){
    
    validate(
      need(length(igraph::V(d))>2, "Betweenness calculation requieres more than two nodes")
      )
    
    if (length(igraph::V(d))>2) {
    
      min_bet = min(igraph::betweenness(d))
      max_bet = max(igraph::betweenness(d))
      
      
      if (min_bet == max_bet) {
      
        min_bet = 1
        max_bet = 10
     
      } 

      labsize <- rescale(igraph::betweenness(d), 
                         min_bet, 
                         max_bet, 
                         min_label, 
                         max_label)
      V(d)$label.cex <- labsize
  
      data <- toVisNetworkData(d)
  
      nodesize <- rescale(igraph::betweenness(d), 
                          min_bet, 
                          max_bet, 
                          min_node, 
                          max_node)
      
      data$nodes$size = nodesize

      n_col =  50
      node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
      
      # x in this function is degree
      col_index = function(x) {((n_col -1)/(max_bet - min_bet))*(x-min_bet)+1}
    
      returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
       
      # Setting parameters straight in the data frame for visNetwork
      data$nodes$color.background = sapply(betweenness(d), FUN = returnColor)
      
      data$nodes$betweenness = format(betweenness(d), digits = 3, nsmall = 3) 
  
      # Setting group in visnetwork format
      data$nodes$group = data$nodes$Group
  
      data$nodes$color.border = sapply(betweenness(d), FUN = returnColor)
  
      # data$nodes$color.highlight = case_when(
      #   data$nodes$Group == "Male" ~ '#47e3ff',
      #   data$nodes$Group == "Female" ~ '#4d00ff',
      #   data$nodes$Group == "Place" ~ '#ff0134',
      #   data$nodes$Group == "God" ~ '#ff4c05'
      # )
      
      data$edges$Relation = rep("to", length(data$edges$from))
      
      # Setting parameters straight in the data frame for visNetwork
      data$edges$color.color = rep("gray",length(data$edges$Relation))
      
      data$edges$color.highlight = rep("gray",length(data$edges$Relation))
    
      # nodes data.frame for legend
      lnodes <- data.frame(label = c("Male", "Female"),
                           shape = c( "dot"), 
                           color = c("#FF6347", "#ffa500"),
                           id = 1:2)
      
      if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
      
      # edges data.frame for legend
      ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                           label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                           arrows = arrow, 
                           font.align = "bottom")
      
      # Shows the name when hovering over the node
      data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                                data$nodes$id,
                                '</p>', 
                                '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                                data$nodes$color.background, 
                                ';">',
                                data$nodes$betweenness,
                                '</p></center>'
                                )
      
      if (directed) {
        
        # Shows the relation when hovering over the edge
        data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$from,
                                  '</p></center>', 
                                  '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                  data$edges$color.color, 
                                  ';">',
                                  data$edges$Relation,
                                  '</p></center>', 
                                  '<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$to, 
                                  '</p></center>'
                                  )  
        
      } else {
        
        # Shows the relation when hovering over the edge
        data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$to,
                                  '</p></center>', 
                                  '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                  data$edges$color.color, 
                                  ';">',
                                  data$edges$Relation,
                                  '</p></center>', 
                                  '<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$from, 
                                  '</p></center>'
                                  )
        
      }
  
      withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
        Sys.sleep(0.25)
  
        incProgress(1, detail = paste("Running visnetwork"))
        
        # Setting seed is important so the graph is always with the same configuration when starts
        set.seed(123)
  
  	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
  	      visNodes(shape = "dot") %>%
  	      visEdges(arrows =list(to = list(enabled = directed)),
  	               color = list(color = "gray",
  	                            highlight = "red")) %>%
          #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
  	      visIgraphLayout()%>%
  	      visOptions(highlightNearest = TRUE)%>%
  visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
   font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
  	    })     
    }  

  }
  if (input$centrality_type == 'closeness'){
    
    min_close = min(igraph::closeness(d))
    max_close = max(igraph::closeness(d))
    
    if (min_close == max_close) {
      
      min_close = 1
      max_close = 10
     
    } 
  
    labsize <- rescale(igraph::closeness(d), 
                       min_close, 
                       max_close, 
                       min_label, 
                       max_label)
    
    V(d)$label.cex <- labsize

    data <- toVisNetworkData(d)
    
    # print("data")
    # print(data) 
    
    nodesize <- rescale(igraph::closeness(d), 
                        min_close, 
                        max_close,
                        min_node, 
                        max_node)
    
    data$nodes$size = nodesize

    n_col =  50
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is degree
    col_index = function(x) {((n_col -1)/(max_close - min_close))*(x-min_close)+1}
  
    returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
     
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(closeness(d), FUN = returnColor)
    
    data$nodes$closeness =  format(igraph::closeness(d), digits = 3, nsmall = 3) 
    
    # Setting group in visnetwork format
    data$nodes$group = data$nodes$Group
    
    closeness_value = igraph::closeness(d)
    
    data$nodes$color.border = sapply(closeness_value, FUN = returnColor)
    
    # data$nodes$color.highlight = case_when(
    #   data$nodes$Group == "Male" ~ '#47e3ff',
    #   data$nodes$Group == "Female" ~ '#4d00ff',
    #   data$nodes$Group == "Place" ~ '#ff0134',
    #   data$nodes$Group == "God" ~ '#ff4c05'
    # )
    
    data$edges$Relation = rep("to", length(data$edges$from))
    
    # Setting parameters straight in the data frame for visNetwork
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
    
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # print("por aqui paso")
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$closeness,
                              '</p></center>'
                              )
    

    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }
    


    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)
      


	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    })
  }
  if (input$centrality_type == 'eigenvector'){
    
    min_eigen = min(igraph::eigen_centrality(d)$vector)
    max_eigen = max(igraph::eigen_centrality(d)$vector)
    
    if (min_eigen == max_eigen) {
      
      min_eigen = 1
      max_eigen = 10
     
    } 
    
    labsize <- rescale(igraph::eigen_centrality(d)$vector, 
                       min_eigen, 
                       max_eigen, 
                       min_label, 
                       max_label)
    
    V(d)$label.cex <- labsize

    data <- toVisNetworkData(d)

    nodesize <- rescale(igraph::eigen_centrality(d)$vector, 
                        min_eigen, 
                        max_eigen, 
                        min_node, 
                        max_node)
    
    data$nodes$size = nodesize

    n_col =  50
    
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is eigen_centrality
    col_index_evc = function(x) {((n_col -1.00)/(max_eigen - min_eigen))*(x - min_eigen)+1.00}
    
    col_index_evc_data = col_index_evc(igraph::eigen_centrality(d)$vector)
  
    returnColor_evc = function(x) {substr(node_vir_col[x],1,nchar(node_vir_col[x])-2)}
    
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)
    
    data$nodes$eigen = format(igraph::eigen_centrality(d)$vector, digits = 3, nsmall = 3)
    
    data$nodes$color.border = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)

    # data$nodes$color.highlight = case_when(
    #   data$nodes$Group == "Male" ~ '#47e3ff',
    #   data$nodes$Group == "Female" ~ '#4d00ff',
    #   data$nodes$Group == "Place" ~ '#ff0134',
    #   data$nodes$Group == "God" ~ '#ff4c05'
    # )
    
    data$edges$Relation = seq(1:length(data$edges$from))
    
    # Setting parameters straight in the data frame for visNetwork
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
  
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$eigen,
                              '</p></center>'
                              )
    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }

    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)

	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    })       
  }
  return(ntw)
    
  })
# Custom
output$graph_map_custom <- visNetwork::renderVisNetwork({
  
  d = graph_reactive_custom()
  
  directed = TRUE
  
  #Set label size
  if (is.null(input$label_size_map[1])) min_label = rescaled_value(0.3,1.0,4)
  else min_label = rescaled_value(0.3,1.0,input$label_size_map[1])

  if (is.null(input$label_size_map[2])) max_label = rescaled_value(0.3,1.0,6)
  else max_label = rescaled_value(0.3,1.0,input$label_size_map[2])
  
  # Set node size
  if (is.null(input$node_size_map[1])) min_node = rescaled_value(10.0,30.0,4)
  else min_node = rescaled_value(10.0,30.0,input$node_size_map[1])

  if (is.null(input$node_size_map[2])) max_node = rescaled_value(10.0,30.0,6)
  else max_node = rescaled_value(10.0,30.0,input$node_size_map[2])
  
  if (input$centrality_type == 'degree'){
    
    min_deg = min(igraph::degree(d))
    max_deg = max(igraph::degree(d))
    
    
    if (min_deg == max_deg) {
      
      min_deg = 1
      max_deg = 10
     
    } 
    
    labsize <- rescale(igraph::degree(d), 
                       min_deg, 
                       max_deg, 
                       min_label, 
                       max_label) 
      
    nodesize <- rescale(igraph::degree(d), 
                        min_deg, 
                        max_deg, 
                        min_node, 
                        max_node)
      
    n_col =  50
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is degree
    col_index = function(x) {((n_col -1)/(max_deg - min_deg))*(x-min_deg)+1}
    
    V(d)$label.cex <- labsize
    
    data <- toVisNetworkData(d)
  
    data$nodes$size = nodesize
    


    returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
     
    
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(igraph::degree(d), FUN = returnColor)
    
    data$nodes$degree = igraph::degree(d)
    
    # Setting group in visnetwork format
    data$nodes$group = data$nodes$Group

    data$nodes$color.border = sapply(igraph::degree(d), FUN = returnColor)
    
    data$edges$Relation = rep("to", length(data$edges$from))
    
    
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
  
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$degree,
                              '</p></center>'
                              )
    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }

    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)
      

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)

	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    }) 
  }
  if (input$centrality_type == 'betweenness'){
    
    validate(
      need(length(igraph::V(d))>2, "Betweenness calculation requieres more than two nodes")
      )
    
    if (length(igraph::V(d))>2) {
    
      min_bet = min(igraph::betweenness(d))
      max_bet = max(igraph::betweenness(d))
      
      
      if (min_bet == max_bet) {
      
        min_bet = 1
        max_bet = 10
     
      } 

      labsize <- rescale(igraph::betweenness(d), 
                         min_bet, 
                         max_bet, 
                         min_label, 
                         max_label)
      V(d)$label.cex <- labsize
  
      data <- toVisNetworkData(d)
  
      nodesize <- rescale(igraph::betweenness(d), 
                          min_bet, 
                          max_bet, 
                          min_node, 
                          max_node)
      
      data$nodes$size = nodesize

      n_col =  50
      node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
      
      # x in this function is degree
      col_index = function(x) {((n_col -1)/(max_bet - min_bet))*(x-min_bet)+1}
    
      returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
       
      # Setting parameters straight in the data frame for visNetwork
      data$nodes$color.background = sapply(betweenness(d), FUN = returnColor)
      
      data$nodes$betweenness = format(betweenness(d), digits = 3, nsmall = 3) 
  
      # Setting group in visnetwork format
      data$nodes$group = data$nodes$Group
  
      data$nodes$color.border = sapply(betweenness(d), FUN = returnColor)
  
      # data$nodes$color.highlight = case_when(
      #   data$nodes$Group == "Male" ~ '#47e3ff',
      #   data$nodes$Group == "Female" ~ '#4d00ff',
      #   data$nodes$Group == "Place" ~ '#ff0134',
      #   data$nodes$Group == "God" ~ '#ff4c05'
      # )
      
      data$edges$Relation = rep("to", length(data$edges$from))
      
      # Setting parameters straight in the data frame for visNetwork
      data$edges$color.color = rep("gray",length(data$edges$Relation))
      
      data$edges$color.highlight = rep("gray",length(data$edges$Relation))
    
      # nodes data.frame for legend
      lnodes <- data.frame(label = c("Male", "Female"),
                           shape = c( "dot"), 
                           color = c("#FF6347", "#ffa500"),
                           id = 1:2)
      
      if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
      
      # edges data.frame for legend
      ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                           label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                           arrows = arrow, 
                           font.align = "bottom")
      
      # Shows the name when hovering over the node
      data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                                data$nodes$id,
                                '</p>', 
                                '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                                data$nodes$color.background, 
                                ';">',
                                data$nodes$betweenness,
                                '</p></center>'
                                )
      
      if (directed) {
        
        # Shows the relation when hovering over the edge
        data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$from,
                                  '</p></center>', 
                                  '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                  data$edges$color.color, 
                                  ';">',
                                  data$edges$Relation,
                                  '</p></center>', 
                                  '<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$to, 
                                  '</p></center>'
                                  )  
        
      } else {
        
        # Shows the relation when hovering over the edge
        data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$to,
                                  '</p></center>', 
                                  '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                  data$edges$color.color, 
                                  ';">',
                                  data$edges$Relation,
                                  '</p></center>', 
                                  '<center><p style = "font-size:14px;font-family:verdana;">',
                                  data$edges$from, 
                                  '</p></center>'
                                  )
        
      }
  
      withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
        Sys.sleep(0.25)
  
        incProgress(1, detail = paste("Running visnetwork"))
        
        # Setting seed is important so the graph is always with the same configuration when starts
        set.seed(123)
  
  	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
  	      visNodes(shape = "dot") %>%
  	      visEdges(arrows =list(to = list(enabled = directed)),
  	               color = list(color = "gray",
  	                            highlight = "red")) %>%
          #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
  	      visIgraphLayout()%>%
  	      visOptions(highlightNearest = TRUE)%>%
  visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
   font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
  	    })     
    }  

  }
  if (input$centrality_type == 'closeness'){
    
    min_close = min(igraph::closeness(d))
    max_close = max(igraph::closeness(d))
    
    if (min_close == max_close) {
      
      min_close = 1
      max_close = 10
     
    } 
  
    labsize <- rescale(igraph::closeness(d), 
                       min_close, 
                       max_close, 
                       min_label, 
                       max_label)
    
    V(d)$label.cex <- labsize

    data <- toVisNetworkData(d)
    
    # print("data")
    # print(data) 
    
    nodesize <- rescale(igraph::closeness(d), 
                        min_close, 
                        max_close,
                        min_node, 
                        max_node)
    
    data$nodes$size = nodesize

    n_col =  50
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is degree
    col_index = function(x) {((n_col -1)/(max_close - min_close))*(x-min_close)+1}
  
    returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
     
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(closeness(d), FUN = returnColor)
    
    data$nodes$closeness =  format(igraph::closeness(d), digits = 3, nsmall = 3) 
    
    # Setting group in visnetwork format
    data$nodes$group = data$nodes$Group
    
    closeness_value = igraph::closeness(d)
    
    data$nodes$color.border = sapply(closeness_value, FUN = returnColor)
    
    # data$nodes$color.highlight = case_when(
    #   data$nodes$Group == "Male" ~ '#47e3ff',
    #   data$nodes$Group == "Female" ~ '#4d00ff',
    #   data$nodes$Group == "Place" ~ '#ff0134',
    #   data$nodes$Group == "God" ~ '#ff4c05'
    # )
    
    data$edges$Relation = rep("to", length(data$edges$from))
    
    # Setting parameters straight in the data frame for visNetwork
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
    
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # print("por aqui paso")
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$closeness,
                              '</p></center>'
                              )
    

    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }
    


    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)
      


	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    })
  }
  if (input$centrality_type == 'eigenvector'){
    
    min_eigen = min(igraph::eigen_centrality(d)$vector)
    max_eigen = max(igraph::eigen_centrality(d)$vector)
    
    if (min_eigen == max_eigen) {
      
      min_eigen = 1
      max_eigen = 10
     
    } 
    
    labsize <- rescale(igraph::eigen_centrality(d)$vector, 
                       min_eigen, 
                       max_eigen, 
                       min_label, 
                       max_label)
    
    V(d)$label.cex <- labsize

    data <- toVisNetworkData(d)

    nodesize <- rescale(igraph::eigen_centrality(d)$vector, 
                        min_eigen, 
                        max_eigen, 
                        min_node, 
                        max_node)
    
    data$nodes$size = nodesize

    n_col =  50
    
    node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
    
    # x in this function is eigen_centrality
    col_index_evc = function(x) {((n_col -1.00)/(max_eigen - min_eigen))*(x - min_eigen)+1.00}
    
    col_index_evc_data = col_index_evc(igraph::eigen_centrality(d)$vector)
  
    returnColor_evc = function(x) {substr(node_vir_col[x],1,nchar(node_vir_col[x])-2)}
    
    # Setting parameters straight in the data frame for visNetwork
    data$nodes$color.background = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)
    
    data$nodes$eigen = format(igraph::eigen_centrality(d)$vector, digits = 3, nsmall = 3)
    
    data$nodes$color.border = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)

    # data$nodes$color.highlight = case_when(
    #   data$nodes$Group == "Male" ~ '#47e3ff',
    #   data$nodes$Group == "Female" ~ '#4d00ff',
    #   data$nodes$Group == "Place" ~ '#ff0134',
    #   data$nodes$Group == "God" ~ '#ff4c05'
    # )
    
    data$edges$Relation = seq(1:length(data$edges$from))
    
    # Setting parameters straight in the data frame for visNetwork
    data$edges$color.color = rep("gray",length(data$edges$Relation))
    
    data$edges$color.highlight = rep("gray",length(data$edges$Relation))
  
    # nodes data.frame for legend
    lnodes <- data.frame(label = c("Male", "Female"),
                         shape = c( "dot"), 
                         color = c("#FF6347", "#ffa500"),
                         id = 1:2)
    
    if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5) 
    
    # edges data.frame for legend
    ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
                         label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"), 
                         arrows = arrow, 
                         font.align = "bottom")
    
    # Shows the name when hovering over the node
    data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
                              data$nodes$id,
                              '</p>', 
                              '<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
                              data$nodes$color.background, 
                              ';">',
                              data$nodes$eigen,
                              '</p></center>'
                              )
    
    if (directed) {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to, 
                                '</p></center>'
                                )  
      
    } else {
      
      # Shows the relation when hovering over the edge
      data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$to,
                                '</p></center>', 
                                '<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
                                data$edges$color.color, 
                                ';">',
                                data$edges$Relation,
                                '</p></center>', 
                                '<center><p style = "font-size:14px;font-family:verdana;">',
                                data$edges$from, 
                                '</p></center>'
                                )
      
    }

    withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
      Sys.sleep(0.25)

      incProgress(1, detail = paste("Running visnetwork"))
      
      # Setting seed is important so the graph is always with the same configuration when starts
      set.seed(123)

	    ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
	      visNodes(shape = "dot") %>%
	      visEdges(arrows =list(to = list(enabled = directed)),
	               color = list(color = "gray",
	                            highlight = "red")) %>%
        #visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
	      visIgraphLayout()%>%
	      visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
 font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
	    })       
  }
  return(ntw)
    
  })

#Diogenes
values = reactive({
  
  graph = graph_reactive()
  
  if (is.igraph(graph)) {  
    
    val =  data.frame(degree = igraph::degree(graph),
    betweenness = as.numeric(format(igraph::betweenness(graph, normalized =TRUE),digits = 3, nsmall = 3)),
                     closeness = as.numeric(format(igraph::closeness(graph),digits = 3, nsmall = 3)),
                     eigenvector = as.numeric(format(igraph::eigen_centrality(graph)$vector,digits = 3, nsmall = 3)))
  #val = val[order(val$degree, decreasing = TRUE),]
  return(val)
  } else {
  
    val = graph
}
    

})
#Life of Phytagoras
values_LOPL <- reactive({
  
  graph = graph_reactive_LOPL()
  
  if (is.igraph(graph)) {  
    
    val =  data.frame(degree = igraph::degree(graph),
    betweenness = as.numeric(format(igraph::betweenness(graph, normalized =TRUE),digits = 3, nsmall = 3)),
                     closeness = as.numeric(format(igraph::closeness(graph),digits = 3, nsmall = 3)),
                     eigenvector = as.numeric(format(igraph::eigen_centrality(graph)$vector,digits = 3, nsmall = 3)))
  #val = val[order(val$degree, decreasing = TRUE),]
  return(val)
  } else {
  
    val = graph
}
    

})
# Custom
values_custom <- reactive({
  
  graph = graph_reactive_custom()
  
  if (is.igraph(graph)) {  
    
    val =  data.frame(degree = igraph::degree(graph),
    betweenness = as.numeric(format(igraph::betweenness(graph, normalized =TRUE),digits = 3, nsmall = 3)),
                     closeness = as.numeric(format(igraph::closeness(graph),digits = 3, nsmall = 3)),
                     eigenvector = as.numeric(format(igraph::eigen_centrality(graph)$vector,digits = 3, nsmall = 3)))
  #val = val[order(val$degree, decreasing = TRUE),]
  return(val)
  } else {
  
    val = graph
}
    

})

#Diogenes
centr = reactive({
  
  graph = graph_reactive()
  
  centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                   closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3))
                   )
  row.names(centr_) = c("Graph")
  return(centr_)
})
# Life of Phytagoras
centr_LOPL_graph = reactive({
  
  graph = graph_reactive_LOPL()
  
  centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                   closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3))
                   )
  row.names(centr_) = c("Graph")
  return(centr_)
})
# Custom
centr_LOPL = reactive({
  
  graph = graph_reactive_custom()
  
  centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3)),
                   closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1], 
                                                 digits = 3, nsmall = 3)),
                   eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1], 
                                                   digits = 3, nsmall = 3))
                   )
  row.names(centr_) = c("Graph")
  return(centr_)
})


# Use the visnetworkOutput function for visnetwork objects


uiOutput("dynamic_graph")

output$dynamic_graph <- renderUI({ 
  if (input$dataset_selection == 'LOPL') {
   visNetworkOutput(outputId="graph_map_LOPL")
  }  else if (input$dataset_selection == 'diogenes') {
    visNetworkOutput(outputId="graph_map")
  } else if (input$dataset_selection == 'custom') {
    visNetworkOutput(outputId="graph_map_custom")
  } 
})
                                                 
```

