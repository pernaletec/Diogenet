max_close,
min_label,
max_label)
V(d)$label.cex <- labsize
data <- toVisNetworkData(d)
# print("data")
# print(data)
nodesize <- rescale(igraph::closeness(d),
min_close,
max_close,
min_node,
max_node)
data$nodes$size = nodesize
n_col =  50
node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
# x in this function is degree
col_index = function(x) {((n_col -1)/(max_close - min_close))*(x-min_close)+1}
returnColor = function(x) {substr(node_vir_col[col_index(x)],1,nchar(node_vir_col[col_index(x)])-2)}
# Setting parameters straight in the data frame for visNetwork
data$nodes$color.background = sapply(closeness(d), FUN = returnColor)
data$nodes$closeness =  format(igraph::closeness(d), digits = 3, nsmall = 3)
# Setting group in visnetwork format
data$nodes$group = data$nodes$Group
closeness_value = igraph::closeness(d)
data$nodes$color.border = sapply(closeness_value, FUN = returnColor)
# data$nodes$color.highlight = case_when(
#   data$nodes$Group == "Male" ~ '#47e3ff',
#   data$nodes$Group == "Female" ~ '#4d00ff',
#   data$nodes$Group == "Place" ~ '#ff0134',
#   data$nodes$Group == "God" ~ '#ff4c05'
# )
data$edges$Relation = rep("to", length(data$edges$from))
# Setting parameters straight in the data frame for visNetwork
data$edges$color.color = rep("gray",length(data$edges$Relation))
data$edges$color.highlight = rep("gray",length(data$edges$Relation))
# nodes data.frame for legend
lnodes <- data.frame(label = c("Male", "Female"),
shape = c( "dot"),
color = c("#FF6347", "#ffa500"),
id = 1:2)
if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5)
# print("por aqui paso")
# edges data.frame for legend
ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"),
arrows = arrow,
font.align = "bottom")
# Shows the name when hovering over the node
data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
data$nodes$id,
'</p>',
'<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
data$nodes$color.background,
';">',
data$nodes$closeness,
'</p></center>'
)
if (directed) {
# Shows the relation when hovering over the edge
data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$from,
'</p></center>',
'<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
data$edges$color.color,
';">',
data$edges$Relation,
'</p></center>',
'<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$to,
'</p></center>'
)
} else {
# Shows the relation when hovering over the edge
data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$to,
'</p></center>',
'<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
data$edges$color.color,
';">',
data$edges$Relation,
'</p></center>',
'<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$from,
'</p></center>'
)
}
withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
Sys.sleep(0.25)
incProgress(1, detail = paste("Running visnetwork"))
# Setting seed is important so the graph is always with the same configuration when starts
set.seed(123)
ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
visNodes(shape = "dot") %>%
visEdges(arrows =list(to = list(enabled = directed)),
color = list(color = "gray",
highlight = "red")) %>%
#visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
visIgraphLayout()%>%
visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
})
}
if (input$centrality_type == 'eigenvector'){
min_eigen = min(igraph::eigen_centrality(d)$vector)
max_eigen = max(igraph::eigen_centrality(d)$vector)
if (min_eigen == max_eigen) {
min_eigen = 1
max_eigen = 10
}
labsize <- rescale(igraph::eigen_centrality(d)$vector,
min_eigen,
max_eigen,
min_label,
max_label)
V(d)$label.cex <- labsize
data <- toVisNetworkData(d)
nodesize <- rescale(igraph::eigen_centrality(d)$vector,
min_eigen,
max_eigen,
min_node,
max_node)
data$nodes$size = nodesize
n_col =  50
node_vir_col = viridis(n = n_col, begin = 0, end = 1, direction = 1, option = "plasma")
# x in this function is eigen_centrality
col_index_evc = function(x) {((n_col -1.00)/(max_eigen - min_eigen))*(x - min_eigen)+1.00}
col_index_evc_data = col_index_evc(igraph::eigen_centrality(d)$vector)
returnColor_evc = function(x) {substr(node_vir_col[x],1,nchar(node_vir_col[x])-2)}
# Setting parameters straight in the data frame for visNetwork
data$nodes$color.background = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)
data$nodes$eigen = format(igraph::eigen_centrality(d)$vector, digits = 3, nsmall = 3)
data$nodes$color.border = sapply(ceiling(col_index_evc_data), FUN = returnColor_evc)
# data$nodes$color.highlight = case_when(
#   data$nodes$Group == "Male" ~ '#47e3ff',
#   data$nodes$Group == "Female" ~ '#4d00ff',
#   data$nodes$Group == "Place" ~ '#ff0134',
#   data$nodes$Group == "God" ~ '#ff4c05'
# )
data$edges$Relation = seq(1:length(data$edges$from))
# Setting parameters straight in the data frame for visNetwork
data$edges$color.color = rep("gray",length(data$edges$Relation))
data$edges$color.highlight = rep("gray",length(data$edges$Relation))
# nodes data.frame for legend
lnodes <- data.frame(label = c("Male", "Female"),
shape = c( "dot"),
color = c("#FF6347", "#ffa500"),
id = 1:2)
if (directed) arrow = c("to", FALSE, FALSE, "to", "to") else  arrow = rep(as.character(FALSE),5)
# edges data.frame for legend
ledges <- data.frame(color = c("#0000FF", "#228B22", "#FF0000", '#ff01d9','#ffbf00'),
label = c("is teacher of", "is friend of", "is family of", "studied the work of", "sent letters to"),
arrows = arrow,
font.align = "bottom")
# Shows the name when hovering over the node
data$nodes$title = paste0('<p style = "font-size:18px;font-weight:bold; font-family: verdana;">',
data$nodes$id,
'</p>',
'<center><p style = "font-size:14px;font-weight:bold;font-family: verdana;color:',
data$nodes$color.background,
';">',
data$nodes$eigen,
'</p></center>'
)
if (directed) {
# Shows the relation when hovering over the edge
data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$from,
'</p></center>',
'<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
data$edges$color.color,
';">',
data$edges$Relation,
'</p></center>',
'<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$to,
'</p></center>'
)
} else {
# Shows the relation when hovering over the edge
data$edges$title =  paste0('<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$to,
'</p></center>',
'<center><p style = "font-size:18px;font-weight:bold;font-family: verdana;color:',
data$edges$color.color,
';">',
data$edges$Relation,
'</p></center>',
'<center><p style = "font-size:14px;font-family:verdana;">',
data$edges$from,
'</p></center>'
)
}
withProgress(message = 'Creating graph', style = 'notification', value = 0.1, {
Sys.sleep(0.25)
incProgress(1, detail = paste("Running visnetwork"))
# Setting seed is important so the graph is always with the same configuration when starts
set.seed(123)
ntw = visNetwork(nodes = data$nodes, edges = data$edges)%>%
visNodes(shape = "dot") %>%
visEdges(arrows =list(to = list(enabled = directed)),
color = list(color = "gray",
highlight = "red")) %>%
#visLegend(addEdges = ledges, addNodes = lnodes, useGroups = FALSE, width = 0.1, zoom = FALSE, position = "right")%>%
visIgraphLayout()%>%
visOptions(highlightNearest = TRUE)%>%
visInteraction(tooltipStyle = 'position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;
font-family: verdana;font-size:14px;font-color:black;background-color: white;border: 1px solid #808074;')
})
}
return(ntw)
})
values = reactive({
graph = graph_reactive()
if (is.igraph(graph)) {
val =  data.frame(degree = igraph::degree(graph),
betweenness = as.numeric(format(igraph::betweenness(graph, normalized =TRUE),digits = 3, nsmall = 3)),
closeness = as.numeric(format(igraph::closeness(graph),digits = 3, nsmall = 3)),
eigenvector = as.numeric(format(igraph::eigen_centrality(graph)$vector,digits = 3, nsmall = 3)))
#val = val[order(val$degree, decreasing = TRUE),]
return(val)
} else {
val = graph
}
})
centr = reactive({
graph = graph_reactive()
centr_ = data.frame(degree = as.numeric(format(igraph::centralization.degree(graph)$centralization[1],
digits = 3, nsmall = 3)),
betweenness = as.numeric(format(igraph::centralization.betweenness(graph)$centralization[1],
digits = 3, nsmall = 3)),
closeness = as.numeric(format(igraph::centralization.closeness(graph)$centralization[1],
digits = 3, nsmall = 3)),
eigenvector = as.numeric(format(igraph::centralization.evcent(graph)$centralization[1],
digits = 3, nsmall = 3))
)
row.names(centr_) = c("Graph")
return(centr_)
})
# Use the visnetworkOutput function for visnetwork objects
visNetworkOutput(outputId="graph_map")
drawn_places_LOPL
#se eligen todo los lugares que esten en las locaciones para el mapa
# Life of Pythagoras
all_places_full_data
library(tidyverse)
library(devtools)
library(leaflet)
library(shiny)
library(DT)
library(geosphere)
library(viridis)
library(igraph)
library(visNetwork)
library(flexdashboard)
library(rmarkdown)
library(knitr)
library(rsconnect)
head(travel_edges_LOPL)
travel_edges_LOPL
travel_edges_LOPL <- read.csv("travel_edges_LOPL.csv")
travel_edges_LOPL
library(tidyverse)
library(devtools)
library(leaflet)
library(shiny)
library(DT)
library(geosphere)
library(viridis)
library(igraph)
library(visNetwork)
library(flexdashboard)
library(rmarkdown)
library(knitr)
library(rsconnect)
travel_edges_LOPL <- read.csv("travel_edges_LOPL.csv")
head(travel_edges_LOPL)
setwd("~/Trabajo/Diogenet_R/Diogenet")
# se definen los edges en funcion del la seleccion del filosofo
travel_edges_LOPL_reactive <- reactive({
return(travel_edges_LOPL)
})
observe(travel_edges_LOPL_reactive())
# se eligen los lugares
# Life of pythagoras
all_places_LOPL_reactive <- reactive({
travel_edges_LOPL <- travel_edges_LOPL_reactive()
all_places_LOPL <- sort(unique(c(travel_edges_LOPL$source,
travel_edges_LOPL$target)),
decreasing = FALSE)
return(data.frame(places_LOPL = all_places_LOPL))
})
observe(all_places_LOPL_reactive())
#se eligen todo los lugares que esten en las locaciones para el mapa
# Life of Pythagoras
all_places_full_data_LOPL_reactive <- reactive({
all_places_LOPL <- all_places_LOPL_reactive()
drawn_places_LOPL <- all_places_full_data$name %in% all_places_LOPL
return(all_places_full_data[drawn_places_LOPL,])
})
#creacion del grafo
graph_reactive_LOPL <- reactive({
travel_edges_LOPL <- travel_edges_LOPL_reactive()
all_places_LOPL <- all_places_LOPL_reactive()
centralities_data_LOPL <- TRUE
# First validate if there are at least two nodes
if (length(all_places_LOPL$places)<2) centralities_data_LOPL <- FALSE
try(graph_LOPL <- igraph::graph_from_data_frame(d = travel_edges_LOPL[,1:2],
directed = FALSE,
vertices = all_places_LOPL$places),
silent = TRUE)
if (centralities_data_LOPL) return(graph_LOPL)
else return("Too few (<2) nodes to calculate centralities")
})
# network stores an object rendered by renderVisnetwork
# Life of Phytagoras
output$travel_network_LOPL <- renderLeaflet({
tcu_map_LOPL <- "https://server.arcgisonline.com/ArcGIS/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}"
map_atrr_LOPL <- map_attr = "Map data &copy<a href='https://developers.arcgis.com/esri-leaflet/maps/display-a-map/'>ArcGIS</a> contributors <a href='http://creativecommons.org/licenses/by-sa/2.0/'>CC-BY-SA</a> Imagery Â© <a href='https://developers.arcgis.com/'>ArcGIS</a>"
m_LOPL <- leaflet() %<%
addTiles(urlTemplate = tcu_map_LOPL, attribution = map_attr_LOPL, options = list(maxZoom = 10,
id = 'isawnyu.map-knmctlkh',
accessToken =  'pk.eyJ1IjoiaXNhd255dSIsImEiOiJBWEh1dUZZIn0.SiiexWxHHESIegSmW8wedQ'))%>%
setView(lng= 24.92, lat = 35.255, zoom = 5)
m_LOPL
})
# rescale the radius of the marker to the min_scale-max_scale scale (5-20)
rescale_radius = function(x, min, max, min_scale, max_scale){
if (min != max) y = ((max_scale-min_scale)/(max-min))*(x-min)+min_scale
else y = min_scale
return(y)
}
# x in this function is centrality vector
col_index = function(x, n_col, min, max) {((n_col -1)/(max - min))*(x-min)+1}
returnColor = function(char_col) {substr(char_col,1,nchar(char_col)-2)}
# Life of Phytagoras
observe({
travel_edges_LOPL <- travel_edges_LOPL_reactive()
travel_edges_LOPL
all_places_LOPL <- all_places_reactive()
graph_LOPL <- graph_reactive_LOPL()
avail_data_tb <- as_tibble(travel_edges_LOPL)
node_count_LOPL <- c(travel_edges_LOPL$source, travel_edges_LOPL$target)
node_count_LOPL <- as.data.frame(table(node_count_LOPL))
all_places_full_data <- all_places_full_data[(all_places_full_data$name %in% all_places_LOPL$places),]
all_places_full_data <- all_places_full_data[order(all_places_full_data$name, decreasing = FALSE),]
values <- values()
all_places_full_data$degree <- values$degree
all_places_full_data$betweenness <- values$betweeenness
all_places_full_data$closeness <- values$closeness
all_places_full_data$eigenvector <- values$eigenvector
n_col <- 50
node_vir_col <- viridis(n = n_col, begin = 0.55, end = 1.0, direction = 1, option = "B")
node_vir_col <- returnColor(node_vir_col)
if(!is.null(input$centrality_type)){
if (input$centrality_type == "degree") {
centrality <- all_places_full_data$degree
}
if(input$centrality_type == "betweenness"){
centrality <- all_places_full_data$betweenness
}
if(input$centrality_type == "eigenvector"){
centrality <- all_places_full_data$eigenvector
}
all_places_full_data$centrality <- centrality
if (length(centrality) > 2){
al <- colorNumeric(node_vir_col, domain = centrality)
min = min(centrality)
max = max(centrality)
} else {
pal <- colorNumeric(node_vir_col, domain = c(1:10))
min = 1
max = 10
}
# Set node size
if (is.null(input$node_size_map[1])) min_node = rescaled_value(5,20,4)
else min_node = rescaled_value(5,20,input$node_size_map[1])
if (is.null(input$node_size_map[2])) max_node = rescaled_value(5,20,6)
else max_node = rescaled_value(5,20,input$node_size_map[2])
text_title = input$centrality_type
leafletProxy("travel_network_LOPL") %>%
clearShapes() %>%
clearMarkers() %>%
clearControls()
for (i in 1:length(travel_edges_LOPL$source)){
arc <- gcIntermediate(p1 = c(as.numeric(travel_edges_LOPL$lon_source[i]),
as.numeric(travel_edges_LOPL$lat_source[i])),
n = 100, addStartEnd = TRUE)
leafletProxy("travel_network_LOPL") %>% addPolylines(
data=arc,
color="black",
weight=1,
stroke = TRUE,
smoothFactor = 5,
fillOpacity = 0.75, popup = paste0("<p><center><b>",
travel_edges_LOPL$name[i],
"</b><br/><small><i>From: </i>",
travel_edges_LOPL$source[i],
"<br/><i>To: </i>",
travel_edges_LOPL$target[i],
"<br/></small></center></p>")
)
}
leafletProxy("travel_network_LOPL") %>%
addCircleMarkers(data = all_places_full_data,
all_places_full_data$lon,
all_places_full_data$lat,
popup = paste0("<p><center><b>",
all_places_full_data$name,
"</b><br/><small><i>Lat: </i>",
all_places_full_data$lat,
"<br/><i>Long: </i>",
all_places_full_data$lon,
"<br/></small></center></p>"),
radius=sapply(X = centrality,
FUN = rescale_radius,
min = min,
max = max,
min_scale = min_node,
max_scale = max_node),
color = ~pal(centrality),
stroke =TRUE,
fillOpacity = 0.75) %>%
addLegend(position = 'bottomright',pal = pal, values = seq(min,max,length.out = 10), title = text_title)
}
})
# Use the visnetworkOutput function for visnetwork objects
leafletOutput(outputId="travels_network_LOPL")
head(travel_edges_LOPL)
setwd("~/Trabajo/Diogenet_R/Diogenet")
head(travel_edges_LOPL)
head(travel_edges_LOPL)
setwd("~/Trabajo/Diogenet_R/Diogenet")
ls()
print(travel_edges_LOPL$target)
travel_edges_LOPL[,1:2]
setwd("~/Trabajo/Diogenet_R/Diogenet")
library(tidyverse)
library(devtools)
library(leaflet)
library(shiny)
library(DT)
library(geosphere)
library(viridis)
library(igraph)
library(visNetwork)
library(flexdashboard)
library(rmarkdown)
library(knitr)
library(rsconnect)
source("travels_data.R")
travel_edges_LOPL <- read.csv("travel_edges_LOPL.csv",header = TRUE, sep = ",", encoding = "UTF-8", stringsAsFactors = FALSE)
# Re-scale sliders
# a and b are the desired initial values in the original scale
# The function return the 0 and 10 values for the 0-10 scale
# The function is built using the a=4 and b=6 values (desired values)
rescaled_value = function(a,b,x) {
y = ((b-a)/(6-4))*(x-4)+a
return(y)
}
# Function to rescale node degree
rescale <- function(x,a,b,c,d){c + (x-a)/(b-a)*(d-c)}
# Menu de seleccion del dataset
selectInput(inputId= "dataset_selection",
label = "select a dataset",
choices = c("Diogenes Laertius" = "diogenes", "Lamblichus" = "LOPL", "Custom" = "custom"),
selected = "LOPL")
# Menu reactivo que se muestra cuando es seleccionado
uiOutput(outputId = 'travelerInput')
selectInput("centrality_type",
label = "Select a Centrality type",
c("Degree" = "degree",
"Betweenness" = "betweenness",
"Closeness" = "closeness",
"Eigenvector" = "eigenvector"))
br()
h4("Appearance")
sliderInput(inputId = "label_size_map", label = "Label Size", min = 0.0, max = 10.0, value = c(4, 6),ticks = TRUE, step = 1)
sliderInput(inputId = "node_size_map", label = "Node Size", min = 0.0, max = 10.0, value = c(4, 6),ticks = TRUE, step = 1)
#boton de subir archivo que se muestra cuando es elegida la opcion custom
uiOutput(outputId = "customInput")
#div(message, style = "color:red")
# Manejador que se encarga de la logica para mostrar los selectinput reactivos (falta agregar el manejador para custom)
output$travelerInput <- renderUI({
# This input exists if the `dataset_selection`
# one is equal to `diogenes` only
if (input$dataset_selection == 'diogenes') {
selectInput(inputId = "philosopher",
label = "Select a Traveler",
choices = c("All", sort(travel_edges$name, decreasing = FALSE)),
selected = "All")
} else if (input$dataset_selection == 'custom') {
selectInput(inputId = "philosopher_custom",
label = "Select a Traveler",
choices = c("All", sort(travel_edges_custom$name, decreasing = FALSE)),  # hay que crear este dataset basado en lo que se suba!!!!
selected = "All")
} else {
return(NULL)
}
})
?tribble
help("as_tibble")
?as_tibble
library(shiny); runApp('~/Escritorio/test.R')
source("~/Escritorio/test.R", echo=TRUE)
source("~/Trabajo/Diogenet_R/Diogenet/travels_data_LOPL.R", echo=TRUE)
source("~/Trabajo/Diogenet_R/Diogenet/travels_data_LOPL.R", echo=TRUE)
source("~/Trabajo/Diogenet_R/Diogenet/travels_data_LOPL.R", echo=TRUE)
source("~/Trabajo/Diogenet_R/Diogenet/travels_data_LOPL.R", echo=TRUE)
source("~/Trabajo/Diogenet_R/Diogenet/travels_data_LOPL.R", echo=TRUE)
source("~/Trabajo/Diogenet_R/Diogenet/travels_data_LOPL.R", echo=TRUE)
source("~/Trabajo/Diogenet_R/Diogenet/travels_data_LOPL.R", echo=TRUE)
